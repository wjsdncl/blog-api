73	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1730977118735-thumbnail.webp	블로그	블로그 개발 일지 #1 - 시작하기	## 사이트를 만들게 된 이유\n\n프론트엔드 개발자로서 **기술을 정리하고 경험을 기록**할 수 있는 개인 사이트를 만들어 보고 싶었습니다.\n\n이 사이트는 단순한 기술 블로그를 넘어 **포트폴리오로 활용 가능한 공간**을 목표로 했습니다.\n또한, 프로젝트 과정에서의 **기술적 성장과 배운 점을 기록하고** 사용자 피드백을 통해 지속적으로 개선할 수 있는 플랫폼을 직접 운영해 보고자 했습니다.\n\n## 기획\n\n개인 사이트 제작을 위해 기획부터 시작했습니다.\n이 사이트를 통해 **기술 역량을 어필할 수 있는 구조**를 만들고자 했고, 이를 위해 크게 **메인 페이지**, **블로그 페이지**, **포트폴리오 페이지**로 나누어 기획했습니다.\n\n- **메인 페이지**: 메인 페이지는 방문자가 사이트에 들어왔을 때 가장 먼저 보게 되는 곳입니다.\n따라서 사이트의 전반적인 내용을 쉽게 파악할 수 있도록 **최신 글과 인기 글을 한눈에 볼 수 있는 구조**로 설계했습니다.\n또한 **스크롤을 통해 포트폴리오의 주요 내용을 간단히 확인**할 수 있도록 구성하여, 사용자가 탐색을 시작하면서 자연스럽게 콘텐츠에 관심을 가질 수 있도록 유도했습니다.\n\n- **블로그 페이지**: 블로그 페이지에서는 **마크다운으로 글을 작성**해 **사용자가 접근하기 쉽고 직관적인 UI**를 유지하려 했습니다.\nVelog와 같은 플랫폼을 참고하여, **글 작성이 간편하고 정돈된 페이지 구성**을 목표로 했습니다.\n또한 블로그에서 필요한 **카테고리와 태그 기능**을 추가하여 특정 주제에 따라 글을 찾을 수 있게 했고, **제목을 초성으로 검색**할 수 있는 기능도 기획했습니다.\n이 기능은 사용자가 특정 글을 빠르게 찾을 수 있도록 돕기 위해 추가했으며, 보다 **사용자 친화적인 검색 경험**을 제공하기 위함입니다.\n\n- **포트폴리오 페이지**: 포트폴리오 페이지는 제가 지금까지 진행한 프로젝트를 소개하는 공간입니다.\n이 페이지에서는 각 프로젝트마다 **사용한 기술**, 그 과정에서 **직면한 문제와 해결 접근법**을 기록하고 있습니다.\n이와 같은 구체적인 설명을 통해 **프로젝트에서의 기여**와 **개발자로서의 역량**을 명확히 드러내고자 했습니다.\n이를 통해 **기술적 성장을 한눈에 볼 수 있는 공간**을 구성하고자 했습니다.\n\n## 고민\n\n사이트를 기획하면서 가장 먼저 고민한 점 중 하나는 **백엔드 구조**였습니다. 백엔드를 **서버리스로 구성할지, 직접 서버를 구축할지**에 대해 여러 가지 고려가 필요했습니다.\n\n서버리스는 **빠른 배포와 높은 확장성**을 제공한다는 점에서 매력적이었습니다.\n이전에 서버리스를 사용하여 배포한 경험이 있었지만, 이번 프로젝트에서는 **백엔드 서버를 직접 구축함으로써 데이터베이스와 API 연동에 대한 경험을 쌓아 보고 싶었습니다.**\n또한 **직접 서버를 관리하고 모니터링**하는 방법을 배우기 위해 **직접 서버를 구축하는 방향**으로 결정했습니다.\n\n## 기술 선정\n\n사이트 제작에 있어 **동적 페이지와 정적 페이지를 모두 활용할 필요**가 있었기 때문에 **Next.js**를 선택했습니다.\nNext.js는 **SSR(Server-Side Rendering)을 지원하여 SEO가 중요한 블로그나 포트폴리오 소개 페이지를 정적으로 생성**할 수 있고, 사용자 맞춤형 콘텐츠는 동적으로 처리할 수 있어 이번 프로젝트에 매우 적합했습니다.\n\n**Tailwind CSS**는 스타일링에서 **일관성을 유지하고 빠르게 개발**할 수 있는 점에서 자주 사용해 왔기 때문에 이번 프로젝트에서도 자연스럽게 선택하게 되었습니다.\n\n또한 **백엔드 개발이 처음이었기 때문에, 데이터베이스와 API를 관리하기 위해 Prisma를 사용**했습니다. Prisma는 **데이터베이스와의 연동을 간편하게 만들어 주어 데이터 모델링 및 API 설계에 큰 도움**을 주었습니다. 그리고 **Render**를 사용해 PostgreSQL과 API를 안정적으로 운영하는 것을 목표로 기획했습니다\n	{프론트엔드,FE,JS,React,Next.js,TailwindCSS,Prisma,PostgreSQL}	1	2024-11-07 06:48:00.525	2025-04-18 05:07:40.187	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-1---시작하기	ㅂㄹㄱㄱㅂㅇㅈㅅㅈㅎㄱ	t
76	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731430198634-thumbnail.webp	블로그	블로그 개발 일지 #3 - 공통 컴포넌트	## 추가적인 공통 컴포넌트 작업\n\n### 토스트 팝업\n전 팀 프로젝트에서 만들었던 토스트 팝업을 가져와서 사용하기로 했습니다. `react-hot-toast`를 참고해서 만들었습니다.\n\n토스트는 **Toast.ts, Toaster.tsx, ToastStore.ts**로 이루어져 있으며, Zustand를 활용하여 전역으로 상태를 관리하였습니다.\n- [Toast](https://github.com/wjsdncl/next_blog/blob/develop/src/utils/Toast.ts) \n  `ToastStore`을 이용해서 토스트를 추가, 수정, 삭제하는 함수를 제공합니다.\n  1. **success, error, warning, info, loading 함수** :\n     - 각각 성공, 에러, 경고, 정보, 로딩 상태의 토스트 메시지를 표시합니다.\n     - 메시지와 타입("success", "error", 등), 지속 시간(duration)을 인수로 받습니다.\n  2. **updateToast 함수** :\n     - 기존에 표시 중인 토스트를 수정합니다.\n     - `id`를 통해 특정 토스트를 식별하고, 메시지와 타입, 지속 시간을 변경합니다.\n  3. **remove 함수** :\n     - 특정 토스트 메시지를 제거합니다.\n     - `id`를 이용해 특정 토스트를 선택적으로 삭제합니다.\n  4. **promise 함수** :\n     - 비동기 작업(Promise)의 상태를 사용자에게 알리기 위해 사용됩니다.\n     - `promise`가 실행 중일 때 `loading` 메시지를 먼저 띄우고, 작업이 완료되면 `success` 메시지를, 실패하면 `error` 메시지를 표시합니다.\n- [Toaster](https://github.com/wjsdncl/next_blog/blob/develop/src/components/Toaster.tsx)\n  전역에 설정되어 사용자에게 토스트 알림을 표시하는 컴포넌트입니다. 주로 상태 관리 라이브러리인 Zustand를 사용해 토스트 상태를 가져오고, 사용자에게 실시간으로 정보를 전달하는 역할을 합니다.\n- [ToastStore](https://github.com/wjsdncl/next_blog/blob/develop/src/stores/ToastStore.ts)\n  상태 관리 라이브러리인 Zustand를 사용하여 토스트 알림 시스템을 구현한 것입니다. `useToastStore`라는 상태 저장소를 만들어 여러 종류의 토스트 메시지를 추가, 수정, 삭제할 수 있도록 합니다.\n\n![토스트 테스트](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/toast.gif)\n\n### Form\n`react-hook-form`을 사용하여 Form 컴포넌트를 만들었습니다.\n[Form](https://github.com/wjsdncl/next_blog/blob/develop/src/components/Form.tsx)은 **컴파운트 컴포넌트 패턴**을 사용해서 만들었습니다.\n\n이 코드에서는 `Form`, `Input`, `Textarea`, `Error`, `Submit` 컴포넌트들이 있으며, 이들을 하나의 컴포넌트로 결합하여 폼을 구성합니다.\n\n각 컴포넌트의 역할을 간단히 설명하겠습니다.\n1. **Form 컴포넌트** : \n   - **Form**은 기본적인 폼 컨테이너 역할을 합니다.\n   - `FormProvider`를 통해 React Hook Form의 상태를 하위 컴포넌트에서 사용할 수 있도록 전파합니다.\n   - `onSubmit` 핸들러로 폼 제출 시 실행될 함수를 받으며, `handleSubmit`을 통해 폼 데이터를 관리합니다.\n2. **Error 컴포넌트** :\n   - `name`을 인수로 받아 해당 필드의 에러 상태를 검사합니다.\n   - 에러가 발생하면 적절한 스타일로 에러 메시지를 화면에 표시합니다.\n3. **Input 컴포넌트** :\n   - 텍스트 입력 필드를 생성하는 컴포넌트입니다.\n   - `type`이 `"password"`인 경우, 아이콘을 클릭하여 비밀번호를 표시하거나 숨길 수 있습니다.\n   - 입력 필드는 `register` 함수를 사용해 React Hook Form에 등록됩니다. 이를 통해 입력 값을 관리하고 유효성 검사를 수행합니다.\n4. **Textarea 컴포넌트** :\n   - 여러 줄의 텍스트 입력을 받을 수 있는 텍스트 영역을 생성하는 컴포넌트입니다.\n   - 마찬가지로 `register` 함수를 사용해 입력 값을 관리합니다.\n5. Submit 컴포넌트\n   - 버튼은 폼의 유효성에 따라 활성화 또는 비활성화됩니다.\n   - 유효하지 않은 경우 버튼은 비활성화되어 사용자에게 시각적으로 폼이 제출될 준비가 안 되었음을 알립니다.\n   - 텍스트 내용은 `text` 프로퍼티로 받아서 기본값은 "입력"으로 설정됩니다.\n6. **컴포넌트 조합** :\n   - 각 필드를 Form 컴포넌트의 속성으로 추가하여 사용할 수 있도록 설정했습니다.\n   - `Form.Error`, `Form.Input`, `Form.Textarea`, `Form.Submit` 형태로 쉽게 접근할 수 있습니다.\n  \n![폼 예시](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731430113912-image.webp)\n\n### Tanstack Query (React Query)\n서버 상태를 관리하기 위해서 **리액트 쿼리**를 사용했습니다.\n[공식 홈페이지](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr#server-components-and-nextjs-app-router)를 참고하여 [**QueryProvider를 설정**](https://github.com/wjsdncl/next_blog/blob/develop/src/components/QueryProvider.tsx)하였습니다.\n\n리액트 쿼리를 이용하여 서버에게서 받은 데이터를 캐싱하여 관리하여 반복적인 요청을 줄이고 클라이언트의 요청에 따라서 최신 상태를 유지합니다.\n\n### svg 이미지 관리\nsvg 이미지를 .tsx 파일로 변환하여 `src/icons/` 폴더에서 관리를 합니다.\n```tsx\n// src/types/IconType.ts\ninterface IconType {\n  width?: number | string;\n  height?: number | string;\n  color?: string;\n}\n\n// src/icons/Favorite.tsx\nexport function FavoriteEmpty({ width = 24, height = 24, color = "#fff" }: IconType) {\n  return (\n    <svg xmlns="http://www.w3.org/2000/svg" height={height} viewBox="0 -960 960 960" width={width} fill={color}>\n      <path d="m480-120-58-52q-101-91-167-157T150-447.5Q111-500 95.5-544T80-634q0-94 63-157t157-63q52 0 99 22t81 62q34-40 81-62t99-22q94 0 157 63t63 157q0 46-15.5 90T810-447.5Q771-395 705-329T538-172l-58 52Zm0-108q96-86 158-147.5t98-107q36-45.5 50-81t14-70.5q0-60-40-100t-100-40q-47 0-87 26.5T518-680h-76q-15-41-55-67.5T300-774q-60 0-100 40t-40 100q0 35 14 70.5t50 81q36 45.5 98 107T480-228Zm0-273Z" />\n    </svg>\n  );\n}\n\n// used\n<FavoriteEmpty width={18} height={18} color="var(--text-primary)" />\n```\n\n이렇게 SVG를 .tsx 파일로 관리하는 이유는 다음과 같습니다\n- 재사용성 향상: SVG를 컴포넌트로 만들어 관리하면 여러 곳에서 쉽게 재사용할 수 있습니다. 다양한 속성을 전달하여 필요한 크기나 색상을 손쉽게 변경할 수 있습니다.\n- 타입 안정성: TypeScript의 장점을 활용해 SVG 컴포넌트에 타입을 부여함으로써, 잘못된 속성 전달을 방지하고 코드의 안정성을 높일 수 있습니다.	{프론트엔드,FE,JS,React,Next.js,TailwindCSS,Prisma,PostgreSQL,Toast,Form,"Tanstack Query",RQ}	2	2024-11-11 18:02:32.187	2025-04-18 05:07:50.986	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-3---공통-컴포넌트	ㅂㄹㄱㄱㅂㅇㅈㄱㅌㅋㅍㄴㅌ	t
79	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731865249691-thumbnail.webp	블로그	블로그 개발 일지 #5 - API 제작	## 백엔드 개발 준비\n\n백엔드 관련 공부를 본격적으로 해본 적은 없었지만, 이전 팀 프로젝트에서 **MongoDB Atlas**를 활용해 간단한 API를 만든 경험이 있었습니다. 당시 부트캠프에서 제공된 API 외에 추가적인 기능을 구현하고 싶어서 **MongoDB Atlas**를 사용하여 진행했습니다.\n\n이번 블로그 프로젝트에서는 직접 백엔드 작업을 하고 서버를 배포하기로 했습니다. 이를 위해 선택한 기술은 **Prisma**와 **PostgreSQL**입니다.\n\n### 기술 스택 선택 이유\n\n#### Prisma\n- **코드 가독성**: Prisma는 Schema-first 방식으로 데이터 모델링을 직관적으로 작성할 수 있어서 생산성이 높습니다.\n- **자동화된 데이터베이스 관리**: 마이그레이션을 효율적으로 관리할 수 있습니다.\n- **강력한 툴링**: Prisma Studio를 활용해 데이터베이스를 시각적으로 확인하고 조작할 수 있습니다.\n\n#### PostgreSQL\n- **데이터 무결성**: 관계형 데이터베이스로 데이터를 정규화하고, 복잡한 관계를 다루기 용이합니다.\n- **확장성**: JSON 데이터 타입 지원, 다양한 확장 기능, 뛰어난 안정성 덕분에 대규모 서비스에도 적합합니다.\n- **오픈소스**: 비용 효율적이고 커뮤니티 지원이 활발합니다.\n\n---\n\n### 모델 정의\n\n프로젝트에서 사용할 주요 데이터 모델을 정의했습니다. 모델은 **User**, **Post**, **Comment**의 세 가지로 구성됩니다.\n\n#### **User**\n\n**User** 모델은 사용자 정보를 관리하기 위해 설계되었습니다.\n사용자는 게시물과 댓글의 주체로서 중요한 역할을 합니다. 이를 통해 사용자와 관련된 데이터(게시물, 댓글 등)를 체계적으로 관리할 수 있습니다.\n\n```prisma\nmodel User {\n  id        String   @id @default(uuid())\n  email     String   @unique\n  name      String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  posts     Post[]\n  comments  Comment[] \n}\n```\n\n- **id**: 사용자를 고유하게 식별하는 ID (UUID 사용).\n- **email**: 유저의 이메일 주소 (고유값).\n- **name**: 유저의 이름 또는 닉네임.\n- **createdAt**: 계정이 생성된 날짜 및 시간.\n- **updatedAt**: 계정 정보가 마지막으로 업데이트된 날짜 및 시간.\n- **posts**: 유저가 작성한 게시물의 리스트.\n- **comments**: 유저가 작성한 댓글의 리스트.\n\n#### **Post**\n\n**Post** 모델은 블로그 게시물을 관리하기 위해 설계되었습니다.\n게시물은 특정 사용자에 의해 작성되고, 댓글 및 다양한 속성과 연관됩니다.\n\n```prisma\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  slug      String   @unique\n  coverImg  String?\n  category  String?\n  title     String\n  content   String\n  tags      String[]\n  likes     Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  userId    String\n  comments  Comment[] \n}\n```\n\n- **id**: 게시물을 고유하게 식별하는 ID (자동 증가 값).\n- **slug**: 게시물을 URL에서 식별하기 위한 고유 문자열.\n- **coverImg**: 게시물의 커버 이미지 URL (선택적).\n- **category**: 게시물의 카테고리 (예: 기술, 라이프스타일 등).\n- **title**: 게시물의 제목.\n- **content**: 게시물의 내용.\n- **tags**: 게시물에 관련된 태그 리스트.\n- **likes**: 게시물이 받은 좋아요 수.\n- **createdAt**: 게시물이 작성된 날짜 및 시간.\n- **updatedAt**: 게시물이 마지막으로 수정된 날짜 및 시간.\n- **user**: 게시물을 작성한 사용자.\n- **comments**: 게시물에 달린 댓글 리스트.\n\n#### **Comment**\n\n**Comment** 모델은 게시물에 달린 댓글 및 대댓글을 관리하기 위해 설계되었습니다.\n댓글은 특정 게시물 및 사용자를 기반으로 작성됩니다.\n\n```prisma\nmodel Comment {\n  id              Int       @id @default(autoincrement())\n  content         String\n  likes           Int       @default(0)\n  createdAt       DateTime  @default(now())\n  updatedAt       DateTime  @updatedAt\n\n  user            User      @relation(fields: [userId], references: [id], onDelete: SetDefault)\n  userId          String    @default("anonymous")\n\n  post            Post      @relation(fields: [postId], references: [id], onDelete: Cascade)\n  postId          Int\n\n  parentComment   Comment?  @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: SetNull)\n  parentCommentId Int?\n\n  replies         Comment[] @relation("CommentReplies")\n\n  @@index([parentCommentId]) \n}\n```\n\n- **id**: 댓글을 고유하게 식별하는 ID (자동 증가 값).\n- **content**: 댓글의 내용.\n- **likes**: 댓글이 받은 좋아요 수.\n- **createdAt**: 댓글이 작성된 날짜 및 시간.\n- **updatedAt**: 댓글이 마지막으로 수정된 날짜 및 시간.\n- **user**: 댓글을 작성한 사용자. 익명의 경우 기본값으로 "anonymous".\n- **post**: 댓글이 달린 게시물.\n- **parentComment**: 대댓글인 경우 부모 댓글을 참조.\n- **replies**: 대댓글 리스트.\n\nPostgreSQL을 기반으로 각 모델 간의 관계를 설정하여 데이터베이스를 설계했습니다. 이를 통해 유저, 게시물, 댓글 간의 데이터 흐름을 직관적으로 관리할 수 있습니다.\n\n---\n\n### 목 데이터 입력\n\n테스트를 하기 전에 데이터베이스 구조를 점검하고 API의 동작을 검증하기 위해 목 데이터를 추가했습니다. 목 데이터는 ChatGPT를 활용해 생성했으며, **Prisma**의 시드 기능을 사용하여 데이터베이스에 삽입했습니다.\n\n#### 1. **목 데이터 생성**\n\n목 데이터를 생성하기 위해 다음과 같은 데이터를 준비했습니다.\n\n- **User 데이터**: 가상의 사용자 4명을 생성하여 다양한 이름과 이메일을 부여했습니다.\n- **Post 데이터**: 총 10개의 게시물을 생성하였으며, 각 게시물은 서로 다른 사용자와 연관됩니다.\n- **Comment 데이터**: 8개의 댓글과 대댓글을 생성하였으며, 댓글과 대댓글의 관계성을 테스트했습니다.\n\n#### 2. **시드 데이터 스크립트**\n\nPrisma를 활용하여 목 데이터를 삽입하기 위한 시드 스크립트를 작성했습니다.\n\n```javascript\nimport { PrismaClient } from "@prisma/client";\nimport { USER, COMMENT, POST } from "./mock.js";\n\nconst prisma = new PrismaClient();\n\nasync function main() {\n  await prisma.comment.deleteMany();\n  await prisma.post.deleteMany();\n  await prisma.user.deleteMany();\n\n  await prisma.user.createMany({ data: USER, skipDuplicates: true });\n  await prisma.post.createMany({ data: POST, skipDuplicates: true });\n  await prisma.comment.createMany({ data: COMMENT, skipDuplicates: true });\n}\n\nmain()\n  .then(async () => {\n    await prisma.$disconnect();\n  })\n  .catch(async (e) => {\n    console.error(e);\n    await prisma.$disconnect();\n    process.exit(1);\n  });\n```\n\n위 스크립트를 실행하기 위해 다음 명령어를 사용했습니다:\n```bash\nnpx prisma db seed\n```\n\n#### 3. **목 데이터 활용**\n\n- **API 동작 확인**: 사용자, 게시물, 댓글 데이터가 올바르게 생성, 조회, 수정, 삭제되는지 확인했습니다.\n- **모델 관계 테스트**: 사용자 삭제 시 관련 게시물과 댓글이 연쇄적으로 삭제되는지 확인했습니다.\n- **필터 및 정렬 테스트**: 태그, 카테고리, 날짜 기준으로 게시물을 필터링 및 정렬하는 기능을 점검했습니다.\n- **대댓글 기능 테스트**: 댓글과 대댓글의 계층 관계가 올바르게 동작하는지 확인했습니다.\n\n---\n\n### 데이터 검증: Superstruct 활용\n\nAPI에서 클라이언트가 전달한 데이터를 검증하기 위해 **Superstruct** 라이브러리를 사용했습니다. 데이터의 스키마와 구조를 선언적으로 정의하여 API 개발의 안정성을 높였습니다.\n\n```javascript\nimport * as s from "superstruct";\nimport isUuid from "is-uuid";\n\nconst Uuid = s.define("Uuid", (value) => isUuid.v4(value));\n\nexport const CreateUser = s.object({\n  email: s.define("Email", isEmail),\n  name: s.size(s.string(), 1, 20),\n});\n\nexport const UpdateUser = s.partial(CreateUser);\n```\n\nSuperstruct를 통해 데이터를 효율적으로 검증하고, API의 신뢰성을 높였습니다.\n\n---\n\n### 에러 핸들링: asyncHandler 활용\n\n비동기 핸들러에서 발생하는 예외를 중앙에서 처리하기 위해 **asyncHandler** 함수를 작성했습니다. 이를 통해 각 핸들러에서 반복적으로 try-catch 블록을 작성하지 않아도 되도록 하여 코드의 가독성과 유지보수성을 높였습니다.\n\n```javascript\nfunction asyncHandler(handler) {\n  return async function (req, res) {\n    try {\n      await handler(req, res);\n    } catch (e) {\n      if (e.name === "StructError" || e instanceof Prisma.PrismaClientValidationError) {\n        res.status(400).send({ message: e.message ?? "Bad Request: Invalid input data." });\n      } else if (e instanceof Prisma.PrismaClientKnownRequestError) {\n        switch (e.code) {\n          case "P2025":\n            res.status(404).send({ message: "Resource not found." });\n            break;\n          case "P2002":\n            res.status(409).send({ message: `Unique constraint failed on: ${e.meta?.target || "unknown field"}` });\n            break;\n          default:\n            res.status(400).send({ message: e.message ?? "Bad Request: Known error." });\n        }\n      } else {\n        res.status(500).send({ message: e.message ?? "Internal Server Error." });\n      }\n    }\n  };\n}\n```\n\n`asyncHandler`를 통해 에러 처리를 체계적으로 구현함으로써 API의 안정성과 유지보수성을 높였습니다.\n\n---\n\n### 깃허브 저장소\n\n> https://github.com/wjsdncl/blog-api	{프론트엔드,FE,JS,React,Next.js,"Tailwind CSS",Prisma,PostgreSQL}	2	2024-11-17 17:40:54.343	2025-04-18 05:08:02.936	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-5---api-제작	ㅂㄹㄱㄱㅂㅇㅈㅈㅈ	t
82	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1732528687907-thumbnail.webp	블로그	블로그 개발 일지 #7 - 블로그 페이지	# 블로그 페이지에 API 연동하기\n\n이전에 연결한 API를 활용하여 블로그 페이지를 동적으로 구현하고자 합니다. 이번 글에서는 게시글 목록 페이지에 API를 연동하여 무한 스크롤이 제대로 동작하는지 확인한 과정을 다루겠습니다.\n\n## 게시글 목록 페이지 API 연동\n\n이전에는 임시 데이터를 이용해 무한 스크롤 기능을 구현했었는데, 이번에는 실제 API와 연동하여 데이터가 정상적으로 표시되는지 확인했습니다.\n\n\n![image](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1732532545545-Screenshot%202024-11-25%20at%2019.39.50.webp)\n아래는 API를 통해 게시글 목록을 가져와 페이지에 출력하는 코드입니다.\n\n```tsx\nimport { useInfiniteQuery } from "@tanstack/react-query";\nimport Link from "next/link";\nimport { useRef, useEffect } from "react";\nimport { getPostList } from "@/services/post.api";\nimport { Post } from "@/types/blogType";\nimport Image from "next/image";\n\nexport default function Page() {\n  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteQuery({\n    queryKey: ["posts"],\n    queryFn: getPostList,\n    getNextPageParam: (lastPage) => (!lastPage.isLast ? lastPage.nextPage : undefined),\n    initialPageParam: 0,\n  });\n\n  const loadMoreRef = useRef(null);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {\n          fetchNextPage();\n        }\n      },\n      { threshold: 0.5 }\n    );\n\n    if (loadMoreRef.current) {\n      observer.observe(loadMoreRef.current);\n    }\n\n    return () => {\n      if (loadMoreRef.current) {\n        observer.unobserve(loadMoreRef.current);\n      }\n    };\n  }, [hasNextPage, isFetchingNextPage, fetchNextPage]);\n\n  return (\n    <div className="mx-auto flex flex-col px-5 py-8">\n      <section className="flex flex-col gap-8">\n        {data?.pages.map((page, pageIndex) =>\n          page.posts.map((blog: Post) => (\n            <article key={`${pageIndex}-${blog.id}`} className="flex flex-col gap-4">\n              <Link href={`/blog/${blog.title.replace(/\\s+/g, "-")}`}>\n                {blog.coverImg && (\n                  <div className="relative flex h-96 w-full items-center justify-center">\n                    <Image src={blog.coverImg} alt="cover image" className="object-cover" fill sizes="300" />\n                  </div>\n                )}\n                <h2 className="text-3xl font-bold">\n                  <span className="pr-2">[{blog.category}]</span>\n                  {blog.title}\n                </h2>\n                <p className="line-clamp-4 text-lg">{blog.content}</p>\n              </Link>\n              <div className="flex gap-1 text-gray-500">\n                <p>{new Date(blog.createdAt).toLocaleDateString("ko-KR", {\n                  year: "numeric",\n                  month: "long",\n                  day: "numeric",\n                })}</p>\n                <span>.</span>\n                <p>댓글 {blog._count?.comments || 0}</p>\n                <span>.</span>\n                <p>좋아요 {blog.likes}</p>\n              </div>\n            </article>\n          ))\n        )}\n      </section>\n\n      <div ref={loadMoreRef} className="flex justify-center py-4">\n        {isFetchingNextPage && <p>로딩 중...</p>}\n      </div>\n    </div>\n  );\n}\n```\n\n### 주요 기능 설명\n\n1. **React Query를 이용한 데이터 페칭**\n\n   `useInfiniteQuery`를 사용해 무한 스크롤을 구현했습니다. API로부터 게시글 데이터를 받아오며, `getNextPageParam`을 통해 다음 페이지의 데이터를 요청할 수 있도록 설정했습니다.\n\n2. **Intersection Observer를 이용한 무한 스크롤**\n\n   `IntersectionObserver`를 사용하여 스크롤의 끝부분에 도달할 때 자동으로 다음 페이지 데이터를 불러오도록 했습니다. `loadMoreRef`에 연결된 요소가 화면에 나타날 때 `fetchNextPage`가 호출됩니다.\n\n3. **게시글 출력**\n\n   API에서 받아온 게시글 목록을 순회하며 화면에 표시합니다. 각 게시글은 제목, 내용, 작성일, 댓글 수, 좋아요 수, 그리고 (있다면) 커버 이미지를 포함하고 있습니다.\n\n## 게시글 상세 페이지 API 연동 및 서버사이드 데이터 페칭\n\n게시글 목록에서 특정 게시글을 클릭하면 해당 게시글의 상세 페이지로 이동하게 됩니다. 이번에는 게시글 상세 페이지를 API와 연동하여 구현한 내용을 다루겠습니다. 또한, 서버사이드에서 데이터를 받아와 클라이언트 페이지에 전달하는 방식도 설명하겠습니다.\n\n![image](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1732532587800-Screenshot%202024-11-25%20at%2018.19.09.webp)\n\n### 주요 기능 설명\n\n1. **React Query를 이용한 게시글 데이터 페칭**\n\n   `useQuery`를 사용하여 특정 게시글의 데이터를 API로부터 받아옵니다. `title`을 이용해 해당 게시글을 식별합니다.\n\n2. **게시글 출력**\n\n   API로 받아온 게시글의 제목, 작성일, 태그, 카테고리, 본문 등을 화면에 표시합니다. 본문은 `ReactMarkdown`을 이용해 마크다운 형식으로 렌더링하며, 코드 블럭은 `react-syntax-highlighter`를 사용해 하이라이팅합니다.\n\n3. **서버사이드 데이터 페칭**\n\n   서버사이드에서 게시글 데이터를 미리 받아와 클라이언트 페이지에 전달하기 위해 `prefetchQuery`를 사용하여 데이터를 사전에 로드합니다. 이 방법은 페이지 로딩 시 초기 데이터를 준비하는 데 유용합니다.\n\n4. **게시글 좋아요 기능 구현**\n\n   사용자가 게시글에 좋아요를 클릭하면, `postLike` 테이블에 해당 사용자의 좋아요 정보가 기록됩니다. 게시글 페이지에 접속할 때마다 서버에서 사용자가 이미 좋아요를 눌렀는지 확인하여, 그에 맞는 하트 아이콘 상태를 동적으로 표시합니다.\n\n```tsx\nimport { dehydrate, HydrationBoundary, QueryClient } from "@tanstack/react-query";\nimport ClientPage from "./_components/ClientPage";\nimport { getPost } from "@/services/post.api";\n\nexport default async function Page({ params }: { params: { title: string } }) {\n  const queryClient = new QueryClient();\n  const title = params.title;\n\n  await queryClient.prefetchQuery({\n    queryKey: ["post", title],\n    queryFn: () => getPost(title),\n  });\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <ClientPage title={title} />\n    </HydrationBoundary>\n  );\n}\n```\n\n\n## 게시글 작성 페이지 구현\n\n이제 블로그 페이지에서 새로운 게시글을 작성할 수 있는 게시글 작성 페이지에 대해 설명하겠습니다. 게시글 작성 페이지에서는 마크다운을 사용하여 콘텐츠를 작성하고, 이미지 업로드 및 미리보기 기능을 제공합니다.\n\n![게시글 작성 페이지 ](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1732528563069-Screenshot%202024-11-25%20at%2018.50.26.webp)\n\n### 마크다운을 활용한 게시글 작성 페이지\n\n`MarkdownEditor` 컴포넌트를 사용하여 사용자는 마크다운 형식으로 콘텐츠를 쉽게 작성할 수 있습니다. 이를 통해 작성자는 텍스트 스타일을 풍부하게 표현하고, 코드 블럭, 리스트, 링크 등 다양한 요소를 직관적으로 추가할 수 있습니다. 마크다운은 간단한 문법으로 복잡한 서식을 지원하기 때문에 블로그 게시글 작성에 매우 적합합니다.\n\n아래는 게시글 작성 페이지의 코드입니다.\n\n```tsx\nimport axios from "axios";\nimport { cookies } from "next/headers";\nimport { redirect } from "next/navigation";\nimport MarkdownEditor from "./_components/MarkdownEditor";\n\nexport default async function Page({ searchParams }: { searchParams: { title: string } }) {\n  const slug = searchParams.title;\n\n  const accessToken = cookies().get("accessToken")?.value ?? "";\n\n  if (accessToken) {\n    const res = await axios.get(`${process.env.NEXT_PUBLIC_BASE_URL}/users/me`, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!res.data.isAdmin) redirect("/blog");\n  } else {\n    redirect("/blog");\n  }\n\n  return <MarkdownEditor slug={slug} />;\n}\n```\n\n### 주요 기능 설명\n\n1. **사용자 인증 및 권한 확인**\n\n   사용자가 게시글 작성 페이지에 접근하려고 할 때, `accessToken`을 통해 사용자가 인증되었는지 확인합니다. 인증되지 않았거나 관리자가 아닌 경우, 블로그 목록 페이지로 리디렉션합니다.\n\n2. **`MarkdownEditor` 컴포넌트 렌더링**\n\n   인증된 사용자에게만 게시글 작성 페이지를 렌더링하며, 이미 작성된 게시글을 수정하려는 경우 `slug` 값을 이용해 해당 게시글 데이터를 불러옵니다.\n\n### 마크다운 에디터\n\n`MarkdownEditor` 컴포넌트는 사용자가 마크다운 형식으로 게시글을 작성할 수 있도록 돕는 에디터입니다. 이미지 업로드 및 미리보기 기능도 제공하여 사용자가 작성 중인 콘텐츠를 미리 확인할 수 있습니다.\n\n```tsx\nimport { useMutation, useQueryClient } from "@tanstack/react-query";\nimport { useRouter } from "next/navigation";\nimport { useForm, Controller } from "react-hook-form";\nimport ReactMarkdown from "react-markdown";\nimport remarkBreaks from "remark-breaks";\nimport remarkGfm from "remark-gfm";\nimport { writePost } from "@/services/post.api";\nimport PreviewModal from "./PreviewModal";\n\nexport default function MarkdownEditor({ slug }: { slug?: string }) {\n  const router = useRouter();\n  const queryClient = useQueryClient();\n  const { handleSubmit, control, watch } = useForm({\n    defaultValues: { title: "", category: "", content: "", tags: [] },\n  });\n  const markdown = watch("content");\n\n  const completeWritingMutation = useMutation({\n    mutationFn: (data) => writePost(data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ["posts"] });\n      router.push("/blog");\n    },\n  });\n\n  return (\n    <form onSubmit={handleSubmit((data) => completeWritingMutation.mutate(data))} className="flex h-dvh w-full">\n      <div className="flex max-w-[50%] basis-1/2 flex-col bg-background-primary">\n        {/* 제목 및 본문 작성 부분 */}\n      </div>\n      <div className="flex max-w-[50%] basis-1/2 flex-col gap-4 overflow-y-auto bg-gray-100 p-[64px_40px_40px]">\n        {/* 마크다운 미리보기 */}\n        <ReactMarkdown remarkPlugins={[remarkGfm, remarkBreaks]}>{markdown}</ReactMarkdown>\n      </div>\n    </form>\n  );\n}\n```\n	{프론트엔드,FE,TS,React,Next.js,TailwindCSS,Prisma,ReactQuery,TanstackQuery}	1	2024-11-25 09:58:13.139	2025-04-18 05:08:10.824	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-7---블로그-페이지	ㅂㄹㄱㄱㅂㅇㅈㅂㄹㄱㅍㅇㅈ	t
85	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1734450126384-thumbnail.webp	블로그	블로그 개발 일지 #10 - 마크다운 에디터 기능 추가	# 마크다운 에디터 기능 추가\n\n개발 블로그에서 글 작성 기능을 향상시키기 위해 마크다운 에디터에 두 가지 주요 기능을 추가했습니다:\n\n1. **TOC (Table of Contents) 목차 기능**  \n2. **이미지 업로드 및 드래그 앤 드롭 지원**\n\n이 기능들은 글 작성과 읽기에 도움이 되도록 구현되었습니다.\n\n---\n\n## 1. TOC (Table of Contents) 목차 기능\n\n### 기능 설명\n\nTOC(목차) 기능은 마크다운에서 사용된 제목(`h1`, `h2`, `h3`)을 자동으로 탐색하여 목차를 생성합니다. 이를 통해 긴 글에서도 **원하는 섹션으로 빠르게 이동**할 수 있습니다.\n\n### 구현 방법\n\n#### 1. 제목 탐색 및 ID 생성\n\n**정규 표현식**을 사용해 마크다운 본문에서 제목을 찾고, 각 제목에 고유한 ID를 자동으로 생성합니다.\n\n```tsx\nconst generateId = (text: string): string =>\n  text\n    .replace(/^#+ /, "")\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z0-9ㄱ-ㅎㅏ-ㅣ가-힣\\s-]/g, "")\n    .replace(/\\s+/g, "-");\n```\n\n- **특수문자 제거**: 제목에서 특수문자를 없애고 공백을 하이픈으로 변환합니다.  \n- **ID 생성**: 각 제목에 고유 ID를 부여해 HTML `id` 속성으로 연결합니다.\n\n#### 2. Intersection Observer를 활용한 동적 강조\n\n`IntersectionObserver`를 사용하여 사용자가 보고 있는 섹션을 실시간으로 감지하고, TOC에서 해당 항목을 강조합니다.\n\n```tsx\nconst handleIntersect = useCallback((entries: IntersectionObserverEntry[]) => {\n  entries.forEach((entry) => {\n    const index = headingElementsRef.current.findIndex((el) => el === entry.target);\n    if (entry.isIntersecting && index !== -1) {\n      setSelectedIndex(index);\n    }\n  });\n}, []);\n```\n\n#### 3. 목차 UI 구현\n\n- 제목의 레벨(`h1`, `h2`, `h3`)에 따라 들여쓰기를 조절합니다.  \n- 클릭 시 스무스 스크롤을 통해 해당 섹션으로 이동합니다.\n\n```tsx\n<li\n  onClick={() => {\n    const targetElement = document.getElementById(id);\n    targetElement?.scrollIntoView({ behavior: "smooth" });\n  }}\n>\n  <a href={`#${id}`}>{text}</a>\n</li>\n```\n\n![image](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1734450757495-image.webp)\n\n### 기능 효과\n\n1. **긴 글 탐색 용이**: TOC를 통해 사용자는 원하는 섹션으로 바로 이동할 수 있습니다.  \n2. **글의 구조 이해**: 목차가 글의 구조를 명확하게 보여주어 독자가 내용을 쉽게 파악할 수 있습니다.  \n3. **동적 강조**: 읽고 있는 섹션이 강조되어, 현재 위치를 쉽게 알 수 있습니다.\n\n---\n\n## 2. 이미지 업로드 기능\n\n### 기능 설명\n\n이미지 업로드 기능은 마크다운 에디터에 다음과 같은 기능을 제공합니다:\n\n1. **드래그 앤 드롭 지원**  \n2. **클립보드 붙여넣기 지원**  \n3. **업로드 상태 표시**: 업로드 중인 이미지는 `![Uploading image...]()`와 같은 텍스트로 표시됩니다.\n4. **파일 업로드 및 리사이징**: 업로드된 이미지는 Supabase Storage에 저장되기 전에 서버에서 크기가 조정됩니다.\n5. **파일 저장 및 URL 반환**: 처리된 이미지는 Supabase Storage에 저장되며, URL이 반환되어 마크다운 콘텐츠에 자동으로 삽입됩니다.\n\n---\n\n### 구현 방법\n\n#### 1. 이미지 드래그 앤 드롭\n\n이미지를 에디터에 드래그하면 업로드가 자동으로 시작됩니다.\n\n```tsx\nconst handleDrop = (event: React.DragEvent) => {\n  event.preventDefault();\n  const file = event.dataTransfer.files[0];\n  if (file && file.type.startsWith("image/")) {\n    handleImageUpload(file, "\\n![Uploading image...]()");\n  }\n};\n```\n\n#### 2. 이미지 클립보드 붙여넣기\n\n클립보드에서 이미지를 복사한 후 붙여넣기하면 자동으로 업로드됩니다.\n\n```tsx\nconst handlePaste = (event: React.ClipboardEvent) => {\n  const items = event.clipboardData.items;\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (item.type.startsWith("image/")) {\n      const file = item.getAsFile();\n      handleImageUpload(file, "\\n![Uploading image...]()");\n    }\n  }\n};\n```\n\n#### 3. 이미지 리사이징 및 업로드 처리\n\n이미지 파일이 서버로 업로드되면, `sharp` 라이브러리를 사용해 리사이징을 진행합니다. `sharp`는 이미지를 효율적으로 처리하는 Node.js 라이브러리로, 파일 크기를 조정하고 WebP 형식으로 변환하는 데 사용됩니다.\n\n```javascript\nasync function processAndUploadImage(buffer, originalName) {\n  const baseName = path.basename(originalName, path.extname(originalName));\n  const filename = `${Date.now()}-${baseName}.webp`;\n\n  const metadata = await sharp(buffer).metadata();\n  const { width: originalWidth, height: originalHeight } = metadata;\n\n  let resizeOptions;\n  if (originalWidth >= originalHeight) {\n    resizeOptions = {\n      width: 1280,\n      height: Math.round((1280 * originalHeight) / originalWidth),\n    };\n  } else {\n    resizeOptions = {\n      width: Math.round((1280 * originalWidth) / originalHeight),\n      height: 1280,\n    };\n  }\n\n  const resizedBuffer = await sharp(buffer)\n    .resize(resizeOptions.width, resizeOptions.height, {\n      fit: "inside",\n      withoutEnlargement: true,\n    })\n    .webp({ quality: 90 })\n    .toBuffer();\n\n  const { data, error } = await supabase.storage\n    .from("images")\n    .upload(filename, resizedBuffer, { contentType: "image/webp" });\n\n  if (error) throw new Error(`이미지 업로드 중 에러 발생: ${error.message}`);\n\n  const result = supabase.storage.from("images").getPublicUrl(data.path);\n  return result.data.publicUrl;\n}\n```\n\n#### 4. 업로드 프로세스 설명\n\n- **파일 형식 및 크기 제한**: `Multer` 미들웨어를 사용해 이미지 파일 크기를 5MB로 제한하고, 허용된 파일 형식만 처리합니다.\n- **리사이징**: 업로드된 이미지는 `sharp`를 이용해 리사이징되며, 1280px로 크기가 조정됩니다.\n- **WebP 형식 변환**: 이미지는 WebP 형식으로 변환되어 저장됩니다.\n- **Supabase Storage에 업로드**: 리사이징된 이미지는 Supabase Storage에 업로드되고, 해당 이미지의 URL이 반환됩니다.\n\n#### 5. 마크다운 콘텐츠에 이미지 삽입\n\n업로드가 완료되면 반환된 URL을 마크다운 이미지 링크 형식으로 콘텐츠에 삽입할 수 있습니다.\n\n```tsx\nconst handleImageUpload = async (file: File, tempText: string) => {\n  setValue("content", `${watch("content")}${tempText}`);\n  try {\n    const imageUrl = await uploadImage(file);\n    setValue("content", watch("content").replace(tempText, `\\n![image](${imageUrl})`));\n  } catch (error) {\n    console.error("Image upload failed:", error);\n  }\n};\n```\n\n### 기능 효과\n\n1. **이미지 업로드 간소화**: 사용자는 파일을 드래그하거나 붙여넣기만 하면 이미지를 손쉽게 업로드할 수 있습니다.\n2. **리사이징 및 품질 유지**: 이미지는 자동으로 리사이징되고 WebP 형식으로 저장되어 품질을 유지하면서 용량을 최적화합니다.\n3. **업로드 상태 표시**: 업로드 중에는 임시 텍스트가 표시되어, 사용자가 업로드 상태를 쉽게 확인할 수 있습니다.	{프론트엔드,FE,TS,React,Next.js,TailwindCSS}	1	2024-12-17 15:42:09.858	2025-04-18 05:08:17.183	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-10-마크다운-에디터-기능-추가	ㅂㄹㄱㄱㅂㅇㅈㅁㅋㄷㅇㅇㄷㅌㄱㄴㅊㄱ	t
83	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1733970003305-thumbnail.webp	블로그	블로그 개발 일지 #8 - 게시글 검색 기능 개선	### 게시글 검색 기능 개선\n\n기존에는 단순히 제목 검색만 가능했던 기능에 초성 검색, 태그 검색, 카테고리 검색을 추가하며 사용자 경험(UX)을 한층 더 향상시키고자 했습니다. 이 과정을 통해 무엇을 고민했고, 어떤 방식으로 구현했는지 상세히 설명드릴게요.\n\n---\n\n## 1. **제목 검색 기능 개선**  \n\n### 문제점  \n기존 검색 기능은 **게시글 제목에 검색어가 포함되어 있는 경우**에만 결과를 반환했습니다. 하지만 사용자가 원하는 게시글을 쉽게 찾기엔 한계가 있었습니다. 특히 제목이 길거나 특정 단어를 초성으로만 기억하는 경우, 검색이 어렵다는 피드백이 있었습니다.\n\n### 개선 과정  \n사용자의 검색 편의성을 높이기 위해 **초성 검색** 기능을 추가하기로 했습니다. 이를 위해 토스에서 개발한 [es-hangul](https://es-hangul.slash.page/) 라이브러리를 활용했습니다.  \n\n- **기존 방식:** 검색어 입력 → 서버에서 게시글 제목 조회  \n- **개선 방식:**  \n  1. **게시글 작성 시, 제목을 초성으로 변환하여 저장**  \n     예를 들어, 제목이 "블로그 검색 기능"이라면, 이를 "ㅂㄹㄱ ㄱㅅ ㄱㄴ"으로 변환하여 데이터베이스에 저장합니다.  \n  2. **검색 시, 초성 데이터로 조회**  \n     사용자가 "ㅂㄹㄱ"을 검색하면 해당 초성 데이터가 포함된 게시글을 반환하도록 구현했습니다.\n\n이 방식으로 검색 과정에서 모든 제목을 초성으로 변환하지 않아도 되어 **서버 부하를 줄이고 검색 속도를 향상**시켰습니다.\n\n### 추가 기능: URL 기반 검색  \n검색 기능을 URL에서도 활용할 수 있도록 `search` 쿼리스트링을 지원했습니다.  \n예:  \n```js\nhttps://example.com/blog?search=ㅂㄹㄱ\n```\n이를 통해 원하는 검색 결과를 쉽게 공유할 수 있는 환경을 마련했습니다.\n\n---\n\n## 2. **태그 검색 기능 추가**\n\n### 문제점  \n게시글 작성 시 태그를 추가하는 기능은 제공하고 있었지만, 이를 활용할 수 있는 검색 기능이 부재했습니다. 결과적으로 사용자는 태그를 통해 게시글을 탐색할 수 없었고, 태그 자체의 활용도도 낮은 상태였습니다.\n\n### 개선 내용  \n태그 검색 기능을 추가해 사용자가 특정 주제의 게시글을 쉽게 찾을 수 있도록 개선했습니다.  \n\n- **사용 방법:**  \n  1. 게시글 목록에서 태그를 클릭 → 해당 태그의 게시글 목록으로 이동  \n  2. URL에 쿼리스트링 `tag`를 추가하여 검색 가능  \n     ```js\n     https://example.com/blog?tag=프론트엔드\n     ```\n\n태그를 활용한 검색이 가능해짐으로써 사용자에게 더 많은 탐색 옵션을 제공할 수 있었습니다.\n\n---\n\n## 3. **카테고리 검색 기능 추가**\n\n### 문제점  \n사이트에 카테고리 구분은 존재했지만, 이를 이용해 게시글을 탐색하는 기능은 부족했습니다. 특히, 특정 카테고리의 게시글만 보고 싶어하는 사용자들에게 불편함이 있었습니다.\n\n### 개선 내용  \n카테고리별로 게시글을 탐색할 수 있는 기능을 추가했습니다.  \n\n- **사용 방법:**  \n  1. 게시글 목록 페이지의 우측에 카테고리 목록을 배치  \n  2. 특정 카테고리를 클릭하면 해당 카테고리에 속한 게시글만 표시  \n  3. URL에 쿼리스트링 `category`를 추가하여 검색 가능  \n     ```\n     https://example.com/blog?category=블로그\n     ```\n\n이를 통해 사용자는 관심 있는 주제의 게시글을 빠르게 탐색할 수 있게 되었습니다.\n\n---\n\n## 4. **검색 기능 개선 후 기대 효과**\n\n이번 개선 작업을 통해 다음과 같은 효과를 기대하고 있습니다.\n\n1. **검색 편의성 증대**  \n   초성 검색, 태그 검색, 카테고리 검색 기능을 추가하여 사용자가 더 직관적이고 간편하게 게시글을 탐색할 수 있습니다.\n\n2. **검색 속도 향상**  \n   초성 데이터를 서버에 미리 저장하여 검색 과정에서의 서버 부하를 줄였습니다.\n\n3. **사이트 활용성 증가**  \n   태그와 카테고리 기능을 적극적으로 활용할 수 있게 되면서 사이트 탐색 방식이 다채로워졌습니다.\n\n4. **공유의 편리함**  \n   URL 기반 검색 기능으로 사용자는 원하는 결과를 쉽게 공유할 수 있습니다.\n\n	{프론트엔드,FE,TS,React,Next.js,TailwindCSS,es-hangul}	1	2024-12-12 02:20:08.06	2025-04-18 05:08:13.78	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-8-게시글-검색-기능-개선	ㅂㄹㄱㄱㅂㅇㅈㄱㅅㄱㄱㅅㄱㄴㄱㅅ	t
89	\N	블로그	개발 블로그를 만든 이유	## 개발 블로그를 만들게 된 이유\n\n프론트엔드를 공부하면서 자연스럽게 “개인 사이트 하나쯤은 있어야 하지 않을까?”라는 생각이 들었습니다.  \n그 생각을 계기로 개발 블로그를 직접 만들어보기로 했습니다. 단순히 블로그를 만드는 데 그치지 않고, 백엔드까지 공부해보고 싶어서 전체적인 구조도 직접 설계하고 구현했습니다.\n\n이번 프로젝트에서는 **Next.js**를 기반으로 프론트엔드를 구성하고, **Prisma**를 활용해 백엔드와 데이터베이스를 연결했습니다. 백엔드는 Express.js와 PostgreSQL을 사용해 간단하게 구축했습니다.\n\n\n## 블로그 + 포트폴리오\n\n처음부터 이 사이트는 단순한 블로그가 아니라 **블로그와 포트폴리오를 함께 볼 수 있는 사이트**로 기획했습니다.\n\n- **블로그**는 주로 제가 공부한 내용이나 작업한 내용을 **일지 형식**으로 기록하는 공간입니다.\n- **포트폴리오**는 지금까지 진행한 프로젝트들을 **문서처럼 정리**해둘 수 있는 공간으로 구성했습니다.\n\n\n## 기술적 구성\n\n블로그는 **Next.js의 App Router**를 사용해서 만들었습니다.  \n**서버 컴포넌트와 클라이언트 컴포넌트를 분리**해서 구조화했고, **초기 데이터는 서버 사이드에서 받아와서 보여주는 방식**으로 구성했습니다.  \n서버 캐싱을 적극적으로 활용했고, 클라이언트의 동적인 데이터 처리에는 **TanStack Query**를 도입했습니다.  \n\n이처럼 **서버 캐싱과 클라이언트 캐싱을 적절히 섞어서 사용**함으로써, 각 방식의 장점을 챙기고자 했습니다.\n\n\n## 개발 중 재밌었던 점\n\n글을 작성할 때 마크다운을 사용하고 싶어서,  \n많이 사용하는 라이브러리인 `react-markdown`, `remark-gfm`, `react-syntax-highlighter`를 활용해 마크다운 렌더링 기능을 직접 구현했습니다.  \n생각보다 쉽게 적용되었고, 실제 글이 마크다운으로 잘 표현되는 걸 보는 게 꽤 재밌었습니다.\n\n![image](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1744955374551-image-1744955372390.webp)\n\n\n## 초기 디자인 방향\n\n디자인은 대부분 **velog**를 참고했습니다. 실제로 UI 구조나 느낌이 많이 닮아 있습니다.  \n개인적으로 **다크모드**를 선호해서 **다크모드만 지원**하고, 포인트 색상으로는 보라색(#656079)을 사용했습니다.\n\n\n## 앞으로의 계획\n\n이 블로그에 앞으로도 꾸준히 공부한 내용을 정리하고, 진행한 프로젝트도 차근차근 포트폴리오로 정리해나갈 계획입니다.  \n꾸준히 기록하는 습관을 들이는 것이 첫 번째 목표입니다.\n\n\n## 사용한 기술 스택\n\n- **Frontend**: `Next.js`, `React`, `TypeScript`, `Tailwind CSS`, `TanStack Query`\n- **Backend**: `Express.js`, `Prisma`, `PostgreSQL`, `Supabase`\n\n	{프론트엔드,Frontend,React,Next.js,TS,TanstackQuery,Tailwind,FE,Prisma,Express.js,PostgreSQL,Supabase,Blog,블로그,포트폴리오}	1	2025-04-18 05:53:12.786	2025-06-09 10:46:36.716	952c6f88-0b2b-4002-80a8-b4d46c7a4032	개발-블로그를-만든-이유	ㄱㅂㅂㄹㄱㄹㅁㄷㅇㅇ	t
74	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731251731964-thumbnail.webp	블로그	블로그 개발 일지 #2 - 기초 작업	## 작업 시작\n프로젝트를 시작할 때 제일 먼저 환경 세팅을 했습니다.\n프로젝트의 효율적인 개발 환경을 만들고 일관된 코드 스타일을 유지하기 위해 ESLint와 Prettier를 설정하고, 폰트와 Tailwind CSS를 추가한 다음, 간단한 메인 페이지를 만들어보았습니다.\n\n이 사이트는 단순한 기술 블로그를 넘어 **포트폴리오로 활용 가능한 공간을 목표**로 했습니다. 또한, 프로젝트 과정에서의 **기술적 성장과 배운 점을 기록**하고 사용자 피드백을 통해 지속적으로 개선할 수 있는 플랫폼을 직접 운영해 보고자 했습니다.\n\n### ESLint\n[ESLint 설정](https://github.com/wjsdncl/next_blog/blob/develop/.eslintrc)\n\nESLint를 먼저 설정해준 이유는 **코드를 작성할 때 바로 문제를 확인하고 수정할 수 있으며, 코드를 깔끔하게 유지할 수 있기 때문**입니다. ESLint 설정 시 여러 블로그와 ChatGPT의 도움을 받아 직접 설정을 했습니다.\n\n유명한 ESLint 패키지를 사용하지 않은 이유는 불필요한 설정들이 많았고, 너무 엄격한 규칙들이 개인 프로젝트에 맞지 않는다고 판단했기 때문입니다. 직접 설정해보면서 모든 규칙을 이해하진 못했지만 어떤 규칙들이 필요한지, 그리고 어떤 설정이 프로젝트에 적합한지 더 잘 이해할 수 있었습니다.\n\n### Prettier\n[Prettier 설정](https://github.com/wjsdncl/next_blog/blob/develop/.prettierrc)\n\n코드를 깔끔하게 작성하기 위해 Prettier를 설정했습니다. Tailwind CSS 플러그인으로 Tailwind 클래스도 정렬되도록 했습니다.\n\n### 공통 컴포넌트 제작 및 홈 페이지 제작\n환경 세팅이 끝난 후에는 공통 컴포넌트와 홈 페이지를 제작했습니다. \n- Header, Footer\n  - 사이트의 거의 모든 부분에 사용되기 때문에 UI 위치를 잡기 위해서 제일 먼저 만들었습니다.\n  - Header에는 사이트의 중요한 링크를 두어 이동하기 편하게 설정했고, 초기에 라이트/다크 모드 설정을 드롭다운으로 추가했습니다. 이는 사용자들이 편리하게 테마를 선택할 수 있도록 하기 위함입니다.\n- [Dropdown](https://github.com/wjsdncl/next_blog/blob/develop/src/components/Dropdown.tsx)\n  - 초기에 라이트/다크 모드를 설정 하기 위해서 제작했습니다.\n- [DelayManager](https://github.com/wjsdncl/next_blog/blob/develop/src/utils/DelayManager.ts) ( debounce, throttle )\n  - debounce, throttle 기능을 사용하기 위해 lodash 라이브러리를 사용하려 했지만, 패키지 크기가 커서 불필요한 로딩 시간을 줄이기 위해 필요한 기능만 따로 구현했습니다.\n- Home 페이지\n  - 제작한 Header와 Footer를 사용하면서 UI 위치를 잡기 위해 임시 메인 페이지를 제작했습니다.\n  - 해당 페이지에는 사이트의 전반적인 내용을 쉽게 파악할 수 있도록 최신 글과 인기 글을 보여줄 예정입니다. 스크롤을 통해 포트폴리오의 주요 내용을 간단히 확인할 수 있도록 구성하여, 사용자가 탐색을 시작하면서 자연스럽게 콘텐츠에 관심을 가질 수 있도록 유도하려고 합니다.\n  ![사이트 이미지](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731217950503-image.webp)\n\n## 작업을 하면서\n이번 프로젝트에서 ESLint와 Prettier 설정을 직접 다루면서 코드의 일관성과 클린 코딩의 중요성을 다시 한 번 체감할 수 있었습니다. 환경 세팅이 처음에는 조금 복잡했지만, 이후 코드 작성 시 많은 시간을 절약할 수 있었습니다.\n	{프론트엔드,FE,JS,React,Next.js,"Tailwind CSS",Prisma,PostgreSQL,ESLint,Prettier}	2	2024-11-10 05:37:47.524	2025-04-18 05:07:45.129	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-2---기초-작업	ㅂㄹㄱㄱㅂㅇㅈㄱㅊㅈㅇ	t
78	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731599139447-thumbnail.webp	블로그	블로그 개발 일지 #4 - 임시 블로그 목록	# 블로그 페이지 제작\n\n## 블로그 게시글 목록\n\n블로그 페이지는 **Velog**의 디자인을 참고하여 제작하기로 했습니다. 먼저 **블로그 게시글 목록 페이지**를 제작하였습니다.\n\n### 게시글 목록 디자인\n\n우선 게시글 목록 페이지의 디자인을 임시로 제작하였습니다. 아래는 해당 디자인의 이미지입니다:\n\n![게시글 목록 디자인](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731596813066-image.webp)\n\n이 디자인을 바탕으로 **게시글 데이터를 어떻게 처리할지** 계획하고, `Post` 모델의 목(mock) 데이터를 생성하기로 했습니다. 이 과정에서 ChatGPT를 활용하여 아래와 같은 형식으로 데이터를 구성했습니다:\n\n```json\n// data/db.json\n{\n  "posts": [\n    {\n      "id": 1,\n      "coverImage": "/images/image.png",\n      "category": "Technology",\n      "title": "Next.js와 TypeScript의 장점",\n      "content": "Next.js와 TypeScript를 사용하여 프로젝트를 효율적으로 관리하는 방법에 대해 설명합니다.",\n      "tags": ["Next.js", "TypeScript", "JavaScript"],\n      "createdAt": "2024-09-01T12:00:00Z",\n      "comments": 5,\n      "likes": 20\n    },\n    {\n      "id": 2,\n      "category": "Lifestyle",\n      "title": "건강한 라이프스타일을 유지하는 방법",\n      "content": "건강한 식단과 운동 루틴으로 건강한 라이프스타일을 유지하는 방법을 소개합니다.",\n      "tags": ["Health", "Lifestyle"],\n      "createdAt": "2024-09-02T14:30:00Z",\n      "comments": 2,\n      "likes": 15\n    }\n  ]\n}\n```\n\n---\n\n### 데이터 구조와 효율성\n\n`Post` 모델의 데이터 구조는 블로그 게시글의 다양한 정보를 담을 수 있도록 설계되었습니다. 각 필드 (`id`, `coverImage`, `category`, `title`, `content`, `tags`, `createdAt`, `comments`, `likes`)는 블로그 페이지의 기능과 사용자 경험을 향상시키기 위해 필요한 요소들을 포함하고 있습니다.\n\n### 데이터 가져오기 및 무한 스크롤 구현\n\n임시로 목 데이터를 불러올 수 있는 데이터 `fetch` 함수를 만들었습니다. 이 데이터는 페이지 번호를 기반으로 **5개씩 잘라서 가져오며**, 무한 스크롤 기능을 구현하기 위해 `React Query`의 `useInfiniteQuery`를 사용했습니다. 이전 포스트에서도 언급했듯이 `React Query`를 선택한 이유는 서버 상태 관리와 캐싱, 데이터의 일관성을 유지하기에 적합하기 때문입니다.\n\n아래는 `fetchBlogs` 함수와 `useInfiniteQuery` 훅을 사용한 코드입니다:\n\n```tsx\nconst fetchBlogs = async ({ pageParam = 1 }) => {\n  const response = await fetch(`/data/db.json`);\n  const jsonData = await response.json();\n\n  const start = (pageParam - 1) * 5;  // 페이지 번호에 따른 시작 인덱스\n  const end = start + 5;               // 5개씩 데이터를 잘라서 가져옴\n  const data = jsonData.posts.slice(start, end);\n\n  return { data, nextPage: pageParam + 1, isLast: data.length < 5 }; // 데이터가 남아있으면 다음 페이지 번호 반환\n};\n\nconst { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteQuery({\n  queryKey: ["posts"],\n  queryFn: fetchBlogs,\n  getNextPageParam: (lastPage) => (!lastPage.isLast ? lastPage.nextPage : undefined),\n  initialPageParam: 1,\n});\n```\n\n이 코드는 `pageParam` 값을 사용하여 현재 페이지 번호에 따른 `start`와 `end` 인덱스를 계산하고, 각 페이지에서 **5개의 데이터를 잘라 반환**하도록 설계되었습니다. 또한, 데이터가 남아 있는 경우에만 `nextPage` 값을 반환하여 무한 스크롤로 데이터를 이어서 불러올 수 있게 합니다.\n\n무한 스크롤 기능 덕분에 사용자는 **버튼 클릭 없이 자연스럽게** 더 많은 게시글을 이어서 읽을 수 있으며, **스크롤하면서도 새로운 내용을 로드**하는 방식으로 콘텐츠 탐색에 몰입할 수 있습니다.\n\n![임시 게시글 목록](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1731596304692-image.webp)\n\n---\n\n### 검색 기능 추가\n\n목 데이터를 기반으로 블로그 게시글 목록의 틀을 잡았으며, 이전에 구현했던 `debounce` 기능을 활용해 **게시글 제목을 검색**할 수 있는 검색 기능도 추가하였습니다. 검색 기능은 사용자가 검색어를 입력할 때마다 서버 요청을 줄이기 위해 일정 시간 지연 후에 검색하도록 구현했습니다.\n\n`debounce`를 활용한 검색 기능을 추가하여 **사용자가 키워드를 빠르게 타이핑**할 때마다 서버에 불필요한 요청이 발생하지 않도록 합니다. 이를 통해 서버 부하를 줄이는 동시에 **응답 속도를 최적화**해, 검색 경험을 쾌적하게 만듭니다. 특히, **사용자가 찾고자 하는 콘텐츠를 빠르게 접근**할 수 있어 탐색이 쉬워집니다.\n\n---\n\n### 초성 검색 기능 추가 계획\n\n현재 구현된 검색 기능은 게시글 제목을 키워드로 검색할 수 있도록 구성되어 있지만, 이후에는 **초성으로도 검색**이 가능하도록 기능을 확장할 계획입니다. 초성 검색은 특히 한글로 작성된 제목에서 유용하게 사용할 수 있는 기능으로, 사용자가 검색어를 보다 편리하게 입력할 수 있도록 도와줍니다.\n\n- **초성 분리 및 매칭 알고리즘**  \n   초성 검색 기능을 위해 [**es-hangul**](https://es-hangul.slash.page/docs/introduction) 라이브러리를 활용할 계획입니다. **es-hangul**은 자음과 모음을 분리하고 초성 검색을 지원하는 기능이 내장되어 있어, 한국어로 작성된 제목에서 초성만을 사용하여 매칭할 수 있게 해줍니다.\n\n추후 이 기능이 추가되면, 사용자는 **한글 초성으로도 쉽게 게시글을 찾을 수 있어 검색 편의성**이 크게 향상될 것입니다.\n\n	{프론트엔드,FE,JS,React,Next.js,"Tailwind CSS",Prisma,PostgreSQL}	1	2024-11-14 15:45:46.675	2025-04-18 05:07:57.753	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-4---임시-블로그-목록	ㅂㄹㄱㄱㅂㅇㅈㅇㅅㅂㄹㄱㅁㄹ	t
81	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1732180806891-thumbnail.webp	블로그	블로그 개발 일지 #6 - API 연동	## API 연동 전 준비\n\n### Axios 설정\n\nAxios를 사용하여 API를 연동하기 전에, 먼저 Axios의 `instance`를 제작하였습니다. 이렇게 생성한 `instance`는 반복되는 설정을 쉽게 재사용할 수 있도록 해줍니다.\n\n```tsx\n// src/services/axios.ts\n\nimport axios from "axios";\nimport { getCookie } from "cookies-next";\n\nconst instance = axios.create({\n  baseURL: process.env.NEXT_PUBLIC_BASE_URL,\n  headers: {\n    "Content-Type": "application/json",\n  },\n});\n\n// 요청 인터셉터 설정 - 모든 요청에 Authorization 헤더에 accessToken을 포함\ninstance.interceptors.request.use((config) => {\n  const token = getCookie("accessToken");\n  if (token) {\n    config.headers = config.headers || {};\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n}, (error) => Promise.reject(error));\n\nexport default instance;\n```\n\n### Axios Instance 사용의 장점\n\nAxios의 `instance`를 사용함으로써 얻는 장점은 다음과 같습니다:\n\n1. **코드 중복 감소**: 매 API 요청마다 반복해서 설정할 필요 없이, 공통된 설정을 한 번에 정의하여 재사용할 수 있습니다. 예를 들어, `baseURL`이나 `Content-Type` 같은 기본 설정을 한 번에 지정할 수 있어 코드의 간결성과 유지보수가 용이합니다.\n\n2. **인증 헤더 자동 처리**: 요청을 보낼 때마다 인증 토큰을 수동으로 추가하는 대신, 요청 인터셉터를 이용해 모든 요청에 `Authorization` 헤더를 자동으로 포함시킬 수 있습니다. 이로 인해 인증 관련 처리가 더 간편하고 실수를 줄일 수 있습니다.\n\n### 요청 인터셉터의 역할\n\n위 코드에서 `interceptors.request`를 사용하여 요청을 인터셉트하고 있습니다. 인터셉터는 요청이 서버로 전송되기 전에 이를 가로채서 추가 작업을 수행할 수 있도록 해줍니다. 여기서는 쿠키에서 `accessToken`을 가져와 모든 요청의 `Authorization` 헤더에 추가하는 작업을 하고 있습니다. 이를 통해 사용자 인증이 필요한 API 요청이 매끄럽게 처리될 수 있습니다.\n\n---\n\n## API 연동\n\n### Auth API (로그인, 회원가입)\n\n먼저 로그인과 회원가입 API를 연동하였습니다.\n\n```tsx\n// src/services/auth.api.ts\nimport instance from "./axios";\nimport { SignInForm, SignInResponse, SignUpForm } from "@/types/authType";\n\nexport const SignUp = async (formData: SignUpForm) => {\n  return await instance.post(`/auth/signup`, formData);\n};\n\nexport const SignIn = async (formData: SignInForm): Promise<SignInResponse> => {\n  return (await instance.post<SignInResponse>(`/auth/login`, formData)).data;\n};\n```\n\n### Auth API 설명\n\nAuth API는 회원가입과 로그인 기능을 제공합니다.\n\n- **회원가입 (`SignUp`)**: 사용자의 이메일, 이름, 비밀번호 등의 정보를 서버에 전달하여 새로운 사용자를 등록합니다.\n- **로그인 (`SignIn`)**: 사용자의 이메일과 비밀번호를 사용해 인증을 요청하고, 성공 시 `accessToken`과 `refreshToken`을 반환하여 이후 API 요청에 사용할 수 있도록 합니다.\n\n이를 통해 사용자 인증을 간편하게 처리하고, 보호된 리소스에 접근할 수 있도록 합니다.\n\n### User API (유저 정보 조회, 수정)\n\n유저 정보를 조회하고 수정하기 위해 User API를 추가로 연동하였습니다.\n\n```tsx\nimport getInstance from "./axios";\nimport { User } from "@/types/authType";\n\nconst instance = getInstance();\n\nexport const getUser = async (): Promise<User> => {\n  return (await instance.get<User>("/users/me")).data;\n};\n\nexport const patchUser = async (id: string, data: patchUserType) => {\n  return await instance.patch(`/users/${id}`, data);\n};\n\ninterface patchUserType {\n  name?: string;\n  isAdmin?: boolean;\n}\n```\n\n### User API 설명\n\n- **유저 정보 조회 (`getUser`)**: 현재 로그인된 사용자의 정보를 조회합니다. 이 API를 통해 사용자 이름, 이메일 등의 정보를 얻을 수 있습니다.\n- **유저 정보 수정 (`patchUser`)**: 특정 유저의 정보를 수정합니다. 사용자의 이름이나 관리자 권한(`isAdmin`) 등을 업데이트할 수 있습니다.\n\n이러한 User API를 통해 사용자의 프로필 정보를 관리하고, 필요한 경우 수정할 수 있는 기능을 제공하였습니다.\n\n### Post API (게시글 조회, 작성, 삭제)\n\n다음으로 게시글 관련 API를 연동하였습니다.\n\n```tsx\n// src/services/post.api.ts\nimport instance from "./axios";\nimport { PostRequest } from "@/types/blogType";\n\nexport const getPostList = async ({ pageParam = 0 }) => {\n  const response = await instance.get(`/posts`, { params: { offset: pageParam, limit: 10 } });\n  return response.data;\n};\n\nexport const getPost = async (title: string) => {\n  return (await instance.get(`/posts/${title}`)).data;\n};\n\nexport const writePost = async ({ postData, userId }: { postData: PostRequest; userId: string }) => {\n  return (await instance.post(`/posts`, { ...postData, userId })).data;\n};\n```\n\n### Post API 설명\n\n- **게시글 목록 조회 (`getPostList`)**: 페이지네이션을 적용하여 특정 페이지의 게시글을 조회합니다. 한 번에 10개의 게시글을 가져오며, 더 이상 가져올 게시글이 없으면 마지막 페이지로 간주합니다.\n- **게시글 상세 조회 (`getPost`)**: 특정 게시글의 제목을 이용해 해당 게시글의 상세 정보를 가져옵니다.\n- **게시글 작성 (`writePost`)**: 사용자가 새로운 게시글을 작성할 수 있도록 합니다. 작성된 게시글의 데이터와 사용자 ID를 서버에 전달하여 새로운 게시글을 생성합니다.\n\n이러한 구조를 통해 게시글 관련 기능들을 일관성 있게 구현하고, 재사용성을 높일 수 있었습니다.\n\n### Comment API (댓글 조회, 작성, 수정, 삭제)\n\n게시글에 대한 댓글 기능을 제공하기 위해 댓글 관련 API를 연동하였습니다.\n\n```tsx\nimport instance from "./axios";\nimport { CommentRequest } from "@/types/blogType";\n\nexport const getComments = async (title: string) => {\n  return (await instance.get(`/comments/${title}`)).data;\n};\n\nexport const writeComment = async (body: CommentRequest) => {\n  return (await instance.post(`/comments`, body)).data;\n};\n\nexport const editComment = async (id: number, content: string) => {\n  return (await instance.patch(`/comments/${id}`, { content })).data;\n};\n\nexport const deleteComment = async (id: number) => {\n  return (await instance.delete(`/comments/${id}`)).data;\n};\n```\n\n### Comment API 설명\n\n- **댓글 목록 조회 (`getComments`)**: 특정 게시글의 제목을 이용해 해당 게시글에 달린 모든 댓글을 조회합니다.\n- **댓글 작성 (`writeComment`)**: 사용자가 새로운 댓글을 작성할 수 있도록 합니다.\n- **댓글 수정 (`editComment`)**: 특정 댓글의 내용을 수정할 수 있도록 합니다.\n- **댓글 삭제 (`deleteComment`)**: 특정 댓글을 삭제할 수 있도록 합니다.\n\n이러한 댓글 관련 기능들을 통해 게시글에 대한 사용자 상호작용을 더욱 풍부하게 만들 수 있었습니다.\n\n---\n\n## 상태 관리 - Zustand를 활용한 전역 상태 관리\n\n유저의 로그인 상태 등과 같은 전역 상태 관리는 **Zustand**를 활용하여 관리하였습니다.\n\n```tsx\n// src/stores/UserStore.ts\n\nimport { getCookie } from "cookies-next";\nimport { create } from "zustand";\n\nconst useUserStore = create((set) => ({\n  isLoggedIn: !!getCookie("accessToken"),\n  setIsLoggedIn: (token) => set({ isLoggedIn: token }),\n}));\n\nexport default useUserStore;\n```\n\n### 전역 상태로 유저 관리의 장점\n\n- **일관된 인증 상태 유지**: 유저의 로그인 상태를 전역에서 관리함으로써, 애플리케이션 전반에서 일관된 인증 상태를 유지할 수 있습니다. 이를 통해 페이지 이동이나 새로고침 이후에도 로그인 상태를 쉽게 확인하고 유지할 수 있습니다.\n\n- **코드의 간결성**: 개별 컴포넌트에서 로그인 여부를 확인하거나 인증 정보를 처리하는 코드를 반복할 필요 없이, 전역 상태에서 이를 통합적으로 관리할 수 있습니다. 이를 통해 코드의 중복을 줄이고 유지보수성을 높일 수 있습니다.\n\n- **효율적인 상태 접근**: 유저의 로그인 상태와 같은 중요한 정보를 여러 컴포넌트에서 사용할 때, 전역 상태를 통해 간편하게 접근할 수 있습니다. 이를 통해 상태 전달을 위한 props drilling을 피할 수 있어, 코드의 복잡도를 줄일 수 있습니다.\n\n이렇게 Zustand를 활용하여 유저의 로그인 상태와 같은 전역 상태를 관리함으로써, 코드의 간결성과 유지보수성을 높이고, 상태 관리의 복잡도를 줄일 수 있었습니다.\n\n---\n\n## 미들웨어 설정\n\n로그인 상태에 따라 특정 페이지로의 접근을 제어하기 위해 **Next.js의 미들웨어**를 사용하여 리다이렉션 처리를 구현하였습니다.\n\n```tsx\n// src/middleware.ts\nimport { NextResponse } from "next/server";\nimport type { NextRequest } from "next/server";\n\nconst authMap = new Map([[ /^\\/(login|signup)/, "/" ]]);\nconst guestMap = new Map([[ /^\\/(get-started|create-team|join-team)/, "/login" ]]);\n\nexport const middleware = (request: NextRequest) => {\n  const { pathname } = request.nextUrl;\n  const accessToken = request.cookies.get("accessToken");\n  const map = accessToken ? authMap : guestMap;\n\n  for (const [regex, redirectUrl] of map.entries()) {\n    if (regex.test(pathname)) {\n      return NextResponse.redirect(new URL(redirectUrl, request.url));\n    }\n  }\n\n  return NextResponse.next();\n};\n\nexport const config = {\n  matcher: ["/((?!api|_next/static|_next/image|favicon.ico|images|icons).*)"],\n};\n```\n\n### 미들웨어 설명\n\n- **로그인 상태에 따른 접근 제어**: 사용자가 로그인 상태인지 아닌지에 따라 특정 경로에 대한 접근을 제어합니다. 로그인 상태일 경우, `/login`이나 `/signup` 페이지로 접근하려고 하면 홈 페이지(`/`)로 리다이렉션됩니다. 반대로, 비로그인 상태일 경우 팀 관련 페이지(`/get-started`, `/create-team`, `/join-team`)로 접근하려고 하면 `/login` 페이지로 리다이렉션됩니다.\n\n- **간편한 접근 제어**: 미들웨어를 통해 요청을 가로채고 필요한 경우 리다이렉션을 처리함으로써, 각 페이지에서 개별적으로 접근 권한을 검사할 필요 없이 전체적인 접근 제어를 일관성 있게 유지할 수 있습니다. 이를 통해 코드의 중복을 줄이고 유지보수성을 높일 수 있습니다.\n\n이러한 미들웨어 설정을 통해 애플리케이션의 보안을 강화하고 사용자 경험을 개선할 수 있었습니다.\n\n	{프론트엔드,FE,JS,React,Next.js,TailwindCSS,Prisma,PostgreSQL,API,Axios}	2	2024-11-21 04:47:43.708	2025-04-18 05:08:06.819	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-6---api-연동	ㅂㄹㄱㄱㅂㅇㅈㅇㄷ	t
84	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1734447431747-thumbnail.webp	블로그	블로그 개발 일지 #9 - 댓글 기능 추가	# 댓글 UI 제작 및 기능 구현\n\n## 댓글 UI 제작\n\n댓글 시스템을 구현하기 위해 React와 다양한 라이브러리를 활용했습니다. **댓글 작성**, **답글 기능**, 그리고 **좋아요 버튼**을 포함하여 사용자 경험을 최적화했습니다.\n\n### 댓글 작성 기능\n\n댓글 작성 UI는 `react-hook-form`을 사용해 간결하고 효율적으로 작성할 수 있도록 설계했습니다.\n\n- **코드 분석**  \n  [Comments.tsx](https://github.com/wjsdncl/next_blog/blob/a0ec968443d11c716ab384916adb839468d1caa9/src/app/blog/%5Btitle%5D/_components/Comments/Comments.tsx#L190) 파일의 핵심 코드입니다:\n\n  ```tsx\n  const { register, handleSubmit, reset, formState: { isSubmitting } } = useForm<CommentFormInputs>();\n\n  const onSubmit = (data: CommentFormInputs) => {\n    if (writeCommentMutation.isPending || !post) return;\n    writeCommentMutation.mutate({\n      content: data.content,\n      postId: post.id as number,\n      userId: user?.id,\n      parentCommentId: undefined,\n    });\n  };\n  ```\n\n  - **`react-hook-form`**: 폼 관리를 위해 사용되었으며, `register`로 입력 필드를 등록합니다.\n  - **`useMutation`**: 댓글 작성 요청을 처리하는 API 호출을 담당합니다.\n  - **`reset`**: 댓글 작성 후 입력 필드를 초기화합니다.\n\n### 댓글과 답글 UI\n\n![image](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1734448542212-image.webp)\n\n\n댓글 UI는 **깊이(depth)** 에 따라 들여쓰기되며 답글의 최대 깊이는 **10**으로 설정했습니다. 이를 통해 답글이 중첩될 경우 사용자 경험을 방해하지 않도록 제한을 두었습니다.\n\n- **코드 분석**  \n  [CommentItem.tsx](https://github.com/wjsdncl/next_blog/blob/develop/src/app/blog/%5Btitle%5D/_components/Comments/CommentItem.tsx)의 주요 부분입니다:\n\n  ```tsx\n  const indentationWidth = Math.min(depth, 5) * 8;\n\n  return (\n    <div style={{ marginLeft: `${indentationWidth}px` }}>\n      {/* 댓글 내용 */}\n      <CommentContent comment={comment} />\n\n      {/* 답글 폼 */}\n      {replyCommentId === comment.id && (\n        <form onSubmit={handleReplySubmit(onReplySubmit)}>\n          <textarea {...replyRegister("content", { required: true })} />\n          <button type="submit">답글 등록</button>\n        </form>\n      )}\n\n      {/* 하위 답글 재귀 렌더링 */}\n      {comment.replies?.map((reply) => (\n        <CommentItem key={reply.id} {...props} depth={depth + 1} />\n      ))}\n    </div>\n  );\n  ```\n\n  - `depth`: 답글 깊이를 기준으로 `margin-left`를 설정해 들여쓰기를 적용합니다.\n  - **재귀 렌더링**: 답글은 재귀적으로 `CommentItem` 컴포넌트를 호출하여 계층 구조를 유지합니다.\n  - **폼 동작**: `react-hook-form`을 사용해 답글 폼을 처리합니다.\n\n---\n\n## 댓글 API 연동\n\n댓글 데이터는 서버와 연동하여 불러오고 수정, 삭제, 좋아요 기능을 제공합니다.\n\n### 댓글 데이터 가져오기\n\n댓글 데이터는 `react-query`를 사용해 비동기적으로 가져옵니다.\n\n```tsx\nconst { data: comments } = useQuery({\n  queryKey: ["comments", post?.id],\n  queryFn: () => getComments(post?.id as number, offset, limit),\n});\n```\n\n- `queryKey`: 쿼리 캐싱을 위해 고유한 키를 사용합니다.\n- `getComments`: API 호출 함수로 서버에서 댓글 데이터를 불러옵니다.\n\n### 댓글 작성 및 답글 기능\n\n댓글과 답글은 같은 API를 사용하지만 `parentCommentId`를 통해 구분됩니다.\n\n```tsx\nconst writeCommentMutation = useMutation({\n  mutationFn: async (body: CommentRequest) => await writeComment(body),\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ["comments"] });\n    toast.success("댓글이 등록되었습니다.");\n  },\n});\n```\n\n- `parentCommentId`:  \n  - 부모 댓글 ID가 `null`인 경우 → 일반 댓글  \n  - 부모 댓글 ID가 있는 경우 → 답글  \n\n---\n\n## 좋아요 기능\n\n댓글에 좋아요를 추가하는 기능은 다음과 같이 구현했습니다.\n\n```tsx\nconst likeCommentMutation = useMutation({\n  mutationFn: async (id: number) => {\n    if (!isLoggedIn) {\n      toast.error("로그인이 필요합니다.");\n      return;\n    }\n    await likeComment(id);\n  },\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ["comments"] });\n  },\n});\n```\n\n- **비로그인 사용자 확인**: 좋아요 기능은 로그인한 사용자만 사용할 수 있도록 설정했습니다.\n- **캐싱 무효화**: `invalidateQueries`를 통해 댓글 데이터를 갱신합니다.\n\n### 좋아요 UI\n\n좋아요 버튼은 조건부 렌더링을 통해 빈 하트 또는 채워진 하트를 보여줍니다.\n\n```tsx\n<button onClick={handleLike}>\n  {comment.isLiked ? <FavoriteFilled /> : <FavoriteEmpty />}\n  {comment.likes}\n</button>\n```\n\n---\n\n## 결론\n\n댓글 시스템은 **작성, 답글, 좋아요, 수정, 삭제** 등 다양한 기능을 제공하며, `react-hook-form`과 `react-query`를 적극적으로 활용해 최적화된 UI/UX를 제공했습니다. 깊이 제한과 재귀 렌더링을 통해 답글의 복잡성을 관리하고 사용자 경험을 개선했습니다.\n\n이 글은 다음과 같은 내용을 다뤘습니다:\n1. **댓글 UI 제작**: 댓글 및 답글 UI, 들여쓰기, 재귀 렌더링\n2. **API 연동**: 댓글 불러오기, 작성, 수정, 삭제, 좋아요 기능\n3. **핵심 코드 분석**: 각 기능의 구현 원리와 이유\n	{프론트엔드,FE,TS,React,Next.js,TailwindCSS,react-hook-form}	1	2024-12-17 14:57:15.756	2025-04-18 05:08:46.943	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-9-댓글-기능-추가	ㅂㄹㄱㄱㅂㅇㅈㄷㄱㄱㄴㅊㄱ	t
86	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1734915304188-thumbnail.webp	블로그	블로그 개발 일지 #11 - 썸네일 기능 추가	## 썸네일 기능 추가\n\n### 썸네일 업로드\n\n사이트 방문자가 게시글을 쉽게 파악할 수 있도록, 이제 게시글에 **썸네일을 추가**할 수 있는 기능을 제공합니다. \n\n- 사용자가 썸네일을 업로드하면 해당 이미지가 게시글 미리보기 화면에 표시됩니다.\n- 만약 사용자가 썸네일을 업로드하지 않으면, 게시글 내용 중 **첫 번째 이미지를 자동으로 썸네일로 설정**합니다.\n\n---\n\n### 코드 설명\n\n#### 1. 이미지 업로드\n\n사용자가 이미지를 선택하면 `handleImageSelection` 함수가 실행되어 이미지를 서버로 업로드하고, 업로드된 이미지 URL을 `coverImg` 상태에 저장합니다.\n\n```tsx\nconst handleImageSelection = async (event: React.ChangeEvent<HTMLInputElement>) => {\n  const file = event.target.files?.[0];\n\n  if (file) {\n    const imageUrl = await uploadImage(file); // 이미지 업로드\n    setCoverImg(imageUrl); // 업로드된 이미지 URL 저장\n  }\n};\n```\n\n#### 2. 자동 썸네일 설정\n\n사용자가 썸네일을 추가하지 않으면, 게시글 내용에서 **첫 번째 이미지를 자동으로 썸네일로 설정**합니다.\n\n```tsx\nconst getFirstImage = (content: string) => {\n  const imgMatch = content.match(/<img[^>]+src="([^">]+)"/);\n  return imgMatch ? imgMatch[1] : ''; // 첫 번째 이미지 URL 반환\n};\n```\n\n---\n\n### 주요 기능\n\n- **이미지 업로드**: 썸네일을 직접 선택하여 업로드 가능\n- **자동 썸네일 설정**: 사용자가 썸네일을 업로드하지 않으면, 게시글 내용 중 첫 번째 이미지를 자동으로 썸네일로 설정\n- **이미지 삭제**: 업로드된 썸네일 이미지는 삭제할 수 있는 버튼을 통해 제거 가능\n\n---\n\n### 결론\n\n이 기능을 통해 게시글 작성자는 **더 매력적인 썸네일**을 추가할 수 있으며, **자동 썸네일 설정** 기능을 통해 사용자가 썸네일을 업로드하지 않아도 게시글이 제대로 노출되도록 보장할 수 있습니다.	{프론트엔드,FE,TS,React,Next.js,TailwindCSS,Thumbnail}	1	2024-12-23 00:52:36.747	2025-04-18 05:08:20.145	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-11-썸네일-기능-추가	ㅂㄹㄱㄱㅂㅇㅈㅆㄴㅇㄱㄴㅊㄱ	t
87	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1735603461618-thumbnail.webp	블로그	블로그 개발 일지 #12 - 메인 페이지	## 메인 페이지\n\n메인 페이지는 방문자가 사이트에 접속했을 때 가장 먼저 접하는 공간으로, 사이트의 주요 내용을 효과적으로 전달하기 위해 다음과 같은 방식으로 설계했습니다.\n\n### 최신 글과 인기 글의 배치\n- **최신 글 섹션**: 메인 페이지 상단에 최신 글을 배치해 방문자가 사이트의 최신 활동을 바로 확인할 수 있도록 했습니다. 예를 들어, 최근에 작성한 기술 블로그 글이나 업데이트 내용을 첫 화면에서 쉽게 확인할 수 있습니다.\n- **인기 글 섹션**: 하단에는 인기 글을 모아두어 사이트를 처음 방문한 사용자도 가장 주목받는 콘텐츠를 쉽게 찾을 수 있도록 했습니다.  \n  - **구체적 구성**: 조회수, 좋아요 수 등 객관적인 지표를 기반으로 콘텐츠를 정렬하여 신뢰성을 높였습니다.\n\n### 콘텐츠 카드 디자인\n- **카드형 레이아웃**: 최신 글과 인기 글은 모두 미리보기 형태의 카드 디자인을 적용했습니다. 카드에는 제목, 간단한 요약, 작성 날짜, 썸네일 이미지를 포함하여 정보를 한눈에 확인할 수 있게 했습니다.  \n  - **배경과 구분되는 박스 스타일**을 적용해 카드 간 시각적 구분이 뚜렷하게 나타나도록 했습니다.  \n  - 각 카드에 클릭 가능한 영역을 충분히 확보해 모바일 사용자도 쉽게 탐색할 수 있도록 배려했습니다.\n\n---\n\n### 향후 개선 방향: 스크롤 활용\n현재는 단순히 최신 글과 인기 글을 나열하는 구조이지만, **스크롤을 활용해 포트폴리오의 주요 내용을 자연스럽게 확인할 수 있는 방식으로 개선할 계획**입니다.  \n- 주요 콘텐츠를 스크롤 이벤트와 연동하여 순차적으로 보여주는 방식을 도입할 예정입니다.  \n- 이를 통해 사용자들이 보다 직관적으로 사이트의 흐름을 이해할 수 있도록 개선하려고 합니다.  \n스크롤 방식의 도입은 방문자의 탐색 경험을 더욱 풍부하게 만들고, 각 섹션의 중요도를 강조할 수 있는 효과적인 방법이 될 것입니다.	{프론트엔드,FE,TS,React,Next.js,TailwindCSS}	1	2024-12-30 00:34:44.834	2025-04-18 05:08:22.897	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-12-메인-페이지	ㅂㄹㄱㄱㅂㅇㅈㅁㅇㅍㅇㅈ	t
88	https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1735523216258-thumbnail.webp	블로그	블로그 개발 일지 #13 - 게시글을 서버사이드로 변경	## 기존 게시글\n\n기존 게시글 페이지는 `[title]/page.tsx`와 `[title]/_components/clientPage.tsx`로 구성되었습니다.  \n`prefetchQuery`를 사용해 서버에서 데이터를 미리 불러와 캐싱하고, 클라이언트 측에서 이 데이터를 기반으로 화면을 그려주는 방식으로 제작되었습니다.\n\n이 방식은 캐싱을 활용해 성능 면에서는 이점이 있었지만, SEO(검색 엔진 최적화)에 최적화되지 않은 문제가 있었습니다. 블로그 게시글의 특성상 대부분의 콘텐츠는 정적인 형태로 제공되며, 사용자와의 상호작용이 많지 않기 때문에 모든 화면을 클라이언트에서 렌더링하는 것은 비효율적이라고 판단했습니다.\n\n---\n\n## 수정된 게시글\n\n수정된 게시글 페이지는 SEO 최적화를 위해 서버사이드 렌더링(SSR)을 도입했습니다. `prefetchQuery`를 사용해 데이터를 미리 가져오는 점은 동일하지만, **클라이언트 전용 컴포넌트인 `clientPage`를 제거**하여 서버에서 바로 데이터를 받아 화면에 출력하도록 변경했습니다.\n\n### 주요 변경 사항\n1. **서버사이드 데이터 로드**  \n   기존에는 데이터를 클라이언트에서 렌더링했지만, 이제는 서버에서 데이터를 가져와 즉시 렌더링합니다. 이를 통해 페이지 로드 시간 단축 및 검색 엔진 크롤링 최적화가 가능해졌습니다.\n\n   ```typescript\n   const queryClient = getQueryClient({ staleTime: 60 * 1000 });\n   await queryClient.prefetchQuery({\n     queryKey: ["post", title],\n     queryFn: () => getPost(title),\n   });\n\n   const post = queryClient.getQueryData<Post>(["post", title]);\n   ```\n\n2. **불필요한 렌더링 제거**  \n   클라이언트에서 데이터를 불러오는 `clientPage` 구조를 제거하여 코드가 더 간결해졌습니다. 이제 서버에서 데이터를 준비해 클라이언트로 전달하므로 불필요한 리소스 사용을 줄였습니다.\n\n3. **Lazy Loading 도입**  \n   클라이언트에서만 필요한 기능(예: 댓글, 목차)은 `next/dynamic`으로 레이지 로딩(Lazy Loading)하여 초기 로딩 속도를 개선했습니다. 이렇게 하면 방문자는 주요 콘텐츠를 더 빠르게 확인할 수 있습니다.\n\n   ```typescript\n   const Navigation = dynamic(() => import("./_components/Navigation"));\n   const GenerateTOC = dynamic(() => import("./_components/GenerateTOC"));\n   const Comments = dynamic(() => import("./_components/Comments/Comments"));\n   ```\n	{프론트엔드,FE,TS,React,Next.js,TailwindCSS}	1	2024-12-30 01:46:59.597	2025-04-18 05:08:26.599	952c6f88-0b2b-4002-80a8-b4d46c7a4032	블로그-개발-일지-13-게시글을-서버사이드로-변경	ㅂㄹㄱㄱㅂㅇㅈㄱㅅㄱㅇㅅㅂㅅㅇㄷㄹㅂㄱ	t
18			마크다운 테스트용 글	\n# 마크다운 테스트 글\n\n## 1. 제목 (Headers)\n\n### 1.1 큰 제목 (H1)\n# 제목 1\n\n### 1.2 중간 제목 (H2)\n## 제목 2\n\n### 1.3 작은 제목 (H3)\n### 제목 3\n\n## 2. 목록 (Lists)\n\n### 2.1 순서가 있는 목록\n1. 첫 번째 항목\n2. 두 번째 항목\n3. 세 번째 항목\n\n### 2.2 순서가 없는 목록\n- 첫 번째 항목\n- 두 번째 항목\n- 세 번째 항목\n\n## 3. 텍스트 강조 (Text Emphasis)\n\n- **굵게 (Bold)**\n- *기울임 (Italic)*\n- ~~취소선 (Strikethrough)~~\n\n## 4. 링크 (Links)\n\n[GitHub](https://github.com/wjsdncl/next_blog)\n\n## 5. 이미지 (Images)\n\n![예시이미지 {200x0}](https://zrkselfyyqkkqcmxhjlt.supabase.co/storage/v1/object/public/images/1744894138056-image-1744894136649.webp)\n\n## 6. 코드 (Code)\n\n### 6.1 인라인 코드\n`console.log('Hello, Markdown!');`\n\n### 6.2 코드 블록\n```javascript\nfunction helloWorld() {\n    console.log('Hello, World!');\n}\n```\n\n## 7. 인용구 (Blockquotes)\n\n> 이것은 인용구입니다. 멋진 문장을 인용할 때 사용하세요.\n\n## 8. 테이블 (Tables)\n\n| 이름 | 나이 | 직업       |\n|:------|:----:|----------:|\n| 홍길동 | 25 | 개발자     |\n| 김철수 | 30 | 디자이너   |\n| 이영희 | 28 | 마케터     |\n\n## 9. 체크리스트 (Task Lists)\n\n- [x] 완료된 항목\n- [ ] 진행 중인 항목\n- [ ] 해야 할 항목\n\n## 10. 수평선 (Horizontal Rules)\n\n---\n\n마크다운 테스트용 글입니다. 다양한 요소를 테스트하고 활용해 보세요!\n	{태그1,태그2,태그3}	3	2024-09-27 15:06:13.719	2025-04-18 05:54:10.845	952c6f88-0b2b-4002-80a8-b4d46c7a4032	마크다운-테스트용-글	ㅁㅋㄷㅇㅌㅅㅌㅇㄱ	f
\.


